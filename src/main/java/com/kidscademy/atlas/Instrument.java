package com.kidscademy.atlas;

import java.io.Serializable;
import java.util.Collections;

import javax.persistence.AttributeOverride;
import javax.persistence.AttributeOverrides;
import javax.persistence.Column;
import javax.persistence.DiscriminatorValue;
import javax.persistence.Embedded;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.PostLoad;
import javax.persistence.PrePersist;
import javax.persistence.Transient;

import com.kidscademy.media.AudioProcessor;
import com.kidscademy.media.AudioSampleInfo;
import com.kidscademy.util.Files;

/**
 * Musical instrument atlas object.
 * 
 * @author Iulian Rotaru
 */
@Entity
@DiscriminatorValue("instrument")
public class Instrument extends AtlasObject implements Serializable
{
  private static final long serialVersionUID = -3922363759020705548L;

  private Category category;
  /** Audio sample title is the name of the instrumental work from which sample is extracted. */
  private String sampleTitle;
  /**
   * Media file name for instrument audio sample. This audio sequence contains a sample from an instrumental work relevant for this instrument. It usually has
   * around 30 seconds, but not strictly. See {@link #pictureName} for details about media file name.
   */
  private String sampleName;
  /**
   * Media file name for audio sample waveform. Waveform is generated by audio processor and has transparent background - see
   * {@link AudioProcessor#generateWaveform(java.io.File, java.io.File)} for details about dimension and aspect ratio. See {@link #pictureName} for details
   * about media file name.
   */
  private String waveformName;

  @Embedded
  @AttributeOverrides(
  {
      @AttributeOverride(name = "value", column = @Column(name = "date_value")), //
      @AttributeOverride(name = "mask", column = @Column(name = "date_mask"))
  })
  private HDate date;

  @Transient
  private AudioSampleInfo sampleInfo;
  /**
   * Root-relative URL, aka media SRC for object picture. It contains root-relative path from repository context to media file and always starts with path
   * separator, e.g. <code>/media/atlas/instrument/accordion/picture.jpg</code>.
   * <p>
   * This field is used by user interface to actually render media file and is not persisted. It is initialized by {@link #postLoad()} immediately after this
   * instrument instance loaded from persistence. When instrument entity is saved to persistence this field is used to initialize related media file name, see
   * {@link #postMerge(Instrument)}.
   */
  @Transient
  private MediaSRC pictureSrc;
  /** Root-relative media SRC for object icon. See {@link #pictureSrc}. */
  @Transient
  private MediaSRC iconSrc;
  /** Root-relative media SRC for object thumbnail. See {@link #pictureSrc}. */
  @Transient
  private MediaSRC thumbnailSrc;
  /** Root-relative media SRC for object audio sample. See {@link #pictureSrc}. */
  @Transient
  private MediaSRC sampleSrc;
  /** Root-relative media SRC for object audio waveform. See {@link #pictureSrc}. */
  @Transient
  private MediaSRC waveformSrc;

  public Instrument()
  {
    dtype = getClass().getSimpleName().toLowerCase();
  }

  /**
   * Hook executed after {@link EntityManager.merge()} to initialize media file names from related root-relative media SRC. This method is executed into a
   * persistent context while this instrument instance is managed, aka attached to context. Source instrument has media SRC properly initialized; it is not
   * attached to persistence context.
   * 
   * @param source unmanaged source instrument.
   * @see Instrument
   */
  public void postMerge(Instrument source)
  {
    pictureName = source.pictureSrc != null ? source.pictureSrc.fileName() : null;
    iconName = source.iconSrc != null ? source.iconSrc.fileName() : null;
    thumbnailName = source.thumbnailSrc != null ? source.thumbnailSrc.fileName() : null;
    sampleName = source.sampleSrc != null ? source.sampleSrc.fileName() : null;
    waveformName = source.waveformSrc != null ? source.waveformSrc.fileName() : null;
  }

  /**
   * Persistence event listener executed before {@link EntityManager#persist(Object)}. It serves the same purpose as {@link #postMerge(Instrument)} but is
   * enacted when instrument is created into database.
   * 
   * @see #postMerge(Instrument)
   */
  @PrePersist
  public void preSave()
  {
    // reuse merge logic but with both SRC and file name from not managed entity
    // instance is not managed yet since it is not yet persisted
    postMerge(this);
  }

  /**
   * Persistence event listener executed just after entity instance is loaded from database. It initializes root-relative media SRC used by web user interface.
   * Delegates {@link Files#mediaSrc(AtlasObject, String)} that knows about media repository context.
   */
  @PostLoad
  public void postLoad()
  {
    // database contains only media file names; convert to root-relative URLs, aka SRC
    pictureSrc = Files.mediaSrc(this, pictureName);
    iconSrc = Files.mediaSrc(this, iconName);
    thumbnailSrc = Files.mediaSrc(this, thumbnailName);
    sampleSrc = Files.mediaSrc(this, sampleName);
    waveformSrc = Files.mediaSrc(this, waveformName);
  }

  public Category getCategory()
  {
    return category;
  }

  public void setCategory(Category category)
  {
    this.category = category;
  }

  public String getSampleTitle()
  {
    return sampleTitle;
  }

  public void setSampleTitle(String sampleTitle)
  {
    this.sampleTitle = sampleTitle;
  }

  public String getSampleName()
  {
    return sampleName;
  }

  public void setSampleName(String samplePath)
  {
    this.sampleName = samplePath;
  }

  public String getWaveformName()
  {
    return waveformName;
  }

  public void setWaveformName(String waveformPath)
  {
    this.waveformName = waveformPath;
  }

  public MediaSRC getPictureSrc()
  {
    return pictureSrc;
  }

  public void setPictureSrc(MediaSRC pictureSrc)
  {
    this.pictureSrc = pictureSrc;
  }

  public MediaSRC getIconSrc()
  {
    return iconSrc;
  }

  public void setIconSrc(MediaSRC iconSrc)
  {
    this.iconSrc = iconSrc;
  }

  public MediaSRC getThumbnailSrc()
  {
    return thumbnailSrc;
  }

  public void setThumbnailSrc(MediaSRC thumbnailSrc)
  {
    this.thumbnailSrc = thumbnailSrc;
  }

  public MediaSRC getSampleSrc()
  {
    return sampleSrc;
  }

  public void setSampleSrc(MediaSRC sampleSrc)
  {
    this.sampleSrc = sampleSrc;
  }

  public MediaSRC getWaveformSrc()
  {
    return waveformSrc;
  }

  public void setWaveformSrc(MediaSRC waveformSrc)
  {
    this.waveformSrc = waveformSrc;
  }

  public void setSampleInfo(AudioSampleInfo sampleInfo)
  {
    this.sampleInfo = sampleInfo;
  }

  public HDate getDate()
  {
    return date;
  }

  public void setDate(HDate date)
  {
    this.date = date;
  }

  @Override
  public String toString()
  {
    // toString is used by Audit to print instrument; leave it as it is
    return name;
  }

  public enum Category
  {
    // ENUM('PERCUSSION','STRINGS','WOODWIND','KEYBOARD')
    /** Instrument is sounded by being struck or scraped by a beater. */
    PERCUSSION,
    /** Produce sound from vibrating strings transmitted to the body of the instrument. */
    STRINGS,
    /** Produce sound by directing a focused stream of air across the edge of a hole in a cylindrical tube. */
    WOODWIND,
    /** A keyboard instrument is a musical instrument played using a keyboard. */
    KEYBOARD
  }

  public static Instrument create(User user)
  {
    Instrument instrument = new Instrument();
    instrument.dtype = Instrument.class.getSimpleName();
    instrument.user = user;
    instrument.state = AtlasObject.State.DEVELOPMENT;
    instrument.aliases = Collections.emptyList();
    instrument.spreading = Collections.emptyList();
    instrument.facts = Collections.emptyMap();
    instrument.links = Collections.emptyList();
    instrument.related = Collections.emptyList();
    return instrument;
  }
}
